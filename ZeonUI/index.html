<html>
<head>
<script src="litegraph.js"></script>
<link href="litegraph.css" rel="stylesheet">
</head>
<body>
<canvas id='mycanvas'></canvas>
</body>
<style>
body, html {
	margin: 0;
	padding: 0;
}

canvas {
	display: block;
}

#node-panel {
	display: none;
}

.litecontextmenu {
	display: none;
}

</style>
<script>
"use strict";

const socket = new WebSocket(`ws://${window.location.host}/ws`);

let can = document.getElementById("mycanvas");
can.width = window.innerWidth;
can.height = window.innerHeight;

window.onresize = () => {
	can.width = window.innerWidth;
	can.height = window.innerHeight;
}

LiteGraph.clearRegisteredTypes();

function set_v(key, value) {
	if (value == undefined) return;
	if (value.match(/^(\d+|\d+\.\d+)$/) || value.match(/^(true|false)$/)) {
		socket.send(JSON.stringify({
			type: "exec",
			code: `set ${key} ${value.trim()}`
		}));
	} else {
		socket.send(JSON.stringify({
			type: "exec",
			code: `set ${key} "${value.trim()}"`,
		}));
	}
}

function ZeonValue()
{
	this.addInput("");
	this.addOutput("");
	this.title = "Value";
	this.name = this.addWidget("text", "Name", "", v => {
		this.key = v + ".";
	}, {});
	this.setValue("");
	this.parent = null;
	this.key = "";
	this.key_cp = "";
}

ZeonValue.prototype.setName = function(name) {
	this.name.value = name;
	this.key = name + ".";
	this.key_cp = this.key;
}

ZeonValue.prototype.onConnectionsChange = function(inout, slot, connected, ...args) {
	if (inout == LiteGraph.OUTPUT) {
		if (!connected && this.outputs[0].links.length == 0) {
			this.setValue(this.val);
		} else {
			this.widgets = [this.widgets[0]];
			this.setSize(this.computeSize());
		}
	} else {
		if (!connected) {
			this.key = "";
			this.key = this.name.value + ".";
		}
	}
}

ZeonValue.prototype.setValue = function(value) {
	this.widgets = [this.widgets[0]];
	this.setSize(this.computeSize());
	this.value = this.addWidget("text", "Value", value, v => {this.val = v}, { multiline:true } );
	this.setBtn = this.addWidget("button", "Set", null, () => {
		console.log(this.key);
		set_v(this.key.slice(0, -1), this.val);
	}, {});
	this.val = value;
}

ZeonValue.prototype.onRemoved = function() {
	socket.send(JSON.stringify({
		type: "exec",
		code: `delete ${this.key_cp.slice(0, -1)}`,
	}));
}

ZeonValue.prototype.onExecute = function() {
	let input = this.getInputData(0);
	if (input == undefined) {
		this.setOutputData(0, {
			nodes: [this],
			value: this.val,
		});

		return;
	};

	for (let node of input.nodes) {
		if (node == this) {
			node.disconnectInput(0);
			return;
		}
	};

	this.parent = input.nodes.at(-1);
	this.key = this.parent.key + this.name.value + ".";
	this.key_cp = this.key;

	this.setOutputData(0, {
		nodes: [...input.nodes, this],
		value: this.val,
	});
}

function DebugNode() {
	this.addInput("");
	this.title = "Debug";
	this.connected = false;
	this.widgets = [];
}

function ActionNode() {
	this.addInput("");
	this.title = "Action";
	this.connected = false;
	this.widgets = [];
}

ActionNode.prototype.onExecute = function() {
	if (this.connected == false) return;

	let data = this.getInputData(0);
	let names = data.nodes.map(n => n.name.value);
	let node = data.nodes.at(-1);
	if (node.node_type == "value") {
	}
	
	this.connected = false;
}

DebugNode.prototype.onConnectionsChange = function(inout, slot, connected, ...args) {
	this.connected = connected;
	if (this.connected == false) {
		this.widgets = [];
		this.setSize(this.computeSize());
	}
}

DebugNode.prototype.onExecute = function() {
	if (this.connected == false) return;

	let data = this.getInputData(0);
	let names = data.nodes.map(n => n.name.value);
	this.addWidget("text", "Path", names.join("."), () => {}, {});
	this.addWidget("text", "Value", data.value, () => {}, {multiline: true});
	this.connected = false;
}

LiteGraph.registerNodeType("value", ZeonValue);
LiteGraph.registerNodeType("debug", DebugNode);

var graph = new LGraph({ allow_interaction: false });
var canvas = new LGraphCanvas("#mycanvas", graph);

function node_gen(tree) {
    let pos = [100, 125];
    let queue = [];
	let iter = 0;
    queue.push({tree, key: "root", pos});
    
    while(queue.length > 0) {
        let current = queue.shift();
        let x = current.pos[0];
        let y = current.pos[1];

		// skip root
		if (iter == 0) {
			iter++;
		} else {
			x += 250;
			var node = LiteGraph.createNode("value");
			node.pos = current.pos;
			node.setName(current.key);
			graph.add(node);

			if (typeof current.tree != "object") {
				if (typeof current.tree == "string") node.setValue(current.tree);
				else node.setValue(JSON.stringify(current.tree));
			}

			if (current.node != undefined) {
				node.parent = current.node;
				current.node.connect(0, node, 0);
			}

			current.node = node;
		}

        if (typeof current.tree != "object") continue;
        
        for (let i in current.tree) {
            queue.push({tree: current.tree[i], key: i, pos: [x, y], node: current.node});
            y += 150;
        }
    }
}

let gen_map = true;

socket.onmessage = (ev) => {
	let data = JSON.parse(ev.data);
	if (data.ok) {
		if (gen_map) {
			let value = JSON.parse(data.value);
			node_gen(value);
			gen_map = false;
		}

		console.log(data.value);
	} else {
		console.error(data.value);
	}
}

socket.onopen = e => {
	socket.send(JSON.stringify({
		type: "exec",
		code: "get $",
	}));
}

graph.start()
</script>

</html>
